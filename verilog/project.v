// This script implement first layer CNN convolutional computation
// Using 16-bit fixed point calculation
// Classification rate is smaller than 28%
// Input data sets are 10000 32*32 RGB CIFAR10 pictures

// Generated by OPAL: 
/* # based on the data strructure in the dictionary file:
#        Shape of element 0: (5, 5, 3, 32)
#        Shape of element 1: (32,)
#        Shape of element 2: (32,)
#        Shape of element 3: (32,)
#        Shape of element 4: (32,)
#        Shape of element 5: (32,)
#        Shape of element 6: (3, 3, 32, 64)
#        Shape of element 7: (64,)
#        Shape of element 8: (64,)
#        Shape of element 9: (64,)
#        Shape of element 10: (64,)
#        Shape of element 11: (64,)
#        Shape of element 12: (7, 7, 64, 64)
#        Shape of element 13: (64,)
#        Shape of element 14: (64,)
#        Shape of element 15: (64,)
#        Shape of element 16: (64,)
#        Shape of element 17: (64,)
#        Shape of element 18: (256, 10)
#        Shape of element 19: (10,)
#        Shape of element 20: (10,)
#        Shape of element 21: (10,)
#        Shape of element 22: (10,)
#        Shape of element 23: (10,)

# The first matrix element will be the first layer, consistes of 32 kernels
# kernel_1: 5*5
# second layer: 64 filters
# kernel_2: 3*3
# third layer: 64 filters
# kernel_3: 7*7
# The last layer is fully connected layer */





module MAC (IN1, IN2, CLK, CLR_MAC, CLR_ACC, OUT_MAC);
/////////////////////////////////////////////////////////////
	// Declare paremeters
	parameter								INT = 8;				// integer resolution of the input/output 
	parameter								DEC = 8;				// decimal resolution of the input/output 
	
	input signed [INT-1:-DEC] 				IN1;
	input signed [INT-1:-DEC] 				IN2;
	input 									CLK, CLR_MAC, CLR_ACC;	// CLR_MAC: clear signal for MAC; CLR_ACC: clear signal for accumulator
	output reg signed [INT-1:-DEC] 			OUT_MAC;

	// Declare registers and wires
	reg signed [INT-1:-DEC] 				IN1_reg, IN2_reg;
	reg  									CLR_ACC_reg;
	reg signed [INT-1:-DEC] 				ACCOut;
	reg signed [2*INT-1:-2*DEC]				MUL;
	wire signed [INT-1:-DEC]				MULOut;					// trucated version of MUL
//////////////////////////////////////////////////////////////	
	
	assign 	MULOut = MUL[INT-1:-DEC];

	// Fixed point multiplications
	always @ (posedge CLK) begin
		// Store the results of the operations on the current data
		if (IN1[INT-1] == 0 & IN2[INT-1] == 0) begin
			MUL <= IN1 * IN2;
		end
		// signed by unsigned (negative by positive)
		if (IN1[INT-1] == 1 & IN2[INT-1] == 0) begin
			MUL <= (
					{{16{IN2[-DEC]}}, (IN1 * IN2[-DEC])} + 
					{{15{IN2[-DEC+1]}}, (IN1 * IN2[-DEC+1])<<1} + 
					{{14{IN2[-DEC+2]}}, (IN1 * IN2[-DEC+2])<<2} + 
					{{13{IN2[-DEC+3]}}, (IN1 * IN2[-DEC+3])<<3} + 
					{{12{IN2[-DEC+4]}}, (IN1 * IN2[-DEC+4])<<4} + 
					{{11{IN2[-DEC+5]}}, (IN1 * IN2[-DEC+5])<<5} + 
					{{10{IN2[-DEC+6]}}, (IN1 * IN2[-DEC+6])<<6} + 
					{{9{IN2[-DEC+7]}}, (IN1 * IN2[-DEC+7])<<7} + 
					{{8{IN2[-DEC+8]}}, (IN1 * IN2[-DEC+8])<<8} + 
					{{7{IN2[-DEC+9]}}, (IN1 * IN2[-DEC+9])<<9} + 
					{{6{IN2[-DEC+10]}}, (IN1 * IN2[-DEC+10])<<10} + 
					{{5{IN2[-DEC+11]}}, (IN1 * IN2[-DEC+11])<<11} +
					{{4{IN2[-DEC+12]}}, (IN1 * IN2[-DEC+12])<<12} + 
					{{3{IN2[-DEC+13]}}, (IN1 * IN2[-DEC+13])<<13} + 
					{{2{IN2[-DEC+14]}}, (IN1 * IN2[-DEC+14])<<14} + 
					{{1{IN2[-DEC+15]}}, (IN1 * IN2[-DEC+15])<<15}
					);
		end
		// unsigned by signed (positive by negative)
		if (IN1[INT-1] == 0 & IN2[INT-1] == 1) begin
			MUL <= (
					(IN1 * IN2[-DEC]) + 
					((IN1 * IN2[-DEC+1])<<1) +
					((IN1 * IN2[-DEC+2])<<2) + 
					((IN1 * IN2[-DEC+3])<<3) + 
					((IN1 * IN2[-DEC+4])<<4) + 
					((IN1 * IN2[-DEC+5])<<5) + 
					((IN1 * IN2[-DEC+6])<<6) + 
					((IN1 * IN2[-DEC+7])<<7) + 
					((IN1 * IN2[-DEC+8])<<8) + 
					((IN1 * IN2[-DEC+9])<<9) + 
					((IN1 * IN2[-DEC+10])<<10) + 
					((IN1 * IN2[-DEC+11])<<11) +
					((IN1 * IN2[-DEC+12])<<12) + 
					((IN1 * IN2[-DEC+13])<<13) + 
					((IN1 * IN2[-DEC+14])<<14) + 
					((1'b1 + ~{1'b0, (IN1 * IN2[-DEC+15])})<<15) 		// last number should add a positive '0' at the MSB and then take the 2's complement
					);				
		end
		
		// signed by signed (negative by negative)
		if (IN1[INT-1] == 1 & IN2[INT-1] == 1) begin
			MUL <= ((~IN1 + 1'b1) * (~IN2 + 1'b1)) << 1; 				// drop the redundant sign bit by left shifting, "7|9"
		end
	end
	
	// Store the value of the accumulation (or clear it)
	always @ (OUT_MAC, CLR_ACC_reg)
	begin
		if (CLR_ACC_reg)
			ACCOut <= 0;
		else
			ACCOut <= OUT_MAC;
	end
	
	// Clear or update data, as appropriate
	always @ (posedge CLK or posedge CLR_MAC)
	begin
		if (CLR_MAC)
		begin
			IN1_reg <= 0;
			IN2_reg <= 0;
			CLR_ACC_reg <= 0;
			OUT_MAC <= 0;
		end
		
		else 
		begin
			IN1_reg <= IN1;
			IN2_reg <= IN2;
			CLR_ACC_reg <= CLR_ACC;
			if (IN1[INT-1] == 1 & IN2[INT-1] == 1) begin
				OUT_MAC <= ACCOut + (MULOut >> 1); 						// shift the 'MUL' back after dropping the redundant bit, "7|9 -> 8|8"
			end
			else begin
				OUT_MAC <= ACCOut + MULOut; 							// DONT shift the if it is not 'signed * signed', "8|8"
			end	
		end
	end
endmodule






// Load the kenel 1 "K1" to BRAM
module BRAM_K1 (Pointer_K1, K1);
//////////////////////////////////////////////////////////////
	parameter							INT = 8;				// integer resolution of the input/output 
	parameter							DEC = 8;				// decimal resolution of the input/output
	
	input [11:0] 						Pointer_K1; 			// index for first K1 vector, 2400 elements
	output reg signed [INT-1:-DEC] 		K1;						// signed binary output
	reg [INT-1:-DEC] 					BRAM_K1 [0:2400-1];
//////////////////////////////////////////////////////////////
	
	always @ (Pointer_K1) begin
		K1 = BRAM_K1 [Pointer_K1];
	end

	initial begin
		$readmemb("kernel_1_b.txt", BRAM_K1);
	end
endmodule





// Load the bias 1 "B1" to BRAM
module BRAM_B1 (Pointer_B1, B1);
//////////////////////////////////////////////////////////////
	parameter							INT = 8;				// integer resolution of the input/output 
	parameter							DEC = 8;				// decimal resolution of the input/output
	
	input [4:0] 						Pointer_B1; 			// index for first B1 vector, 32 elements
	output reg signed [INT-1:-DEC] 		B1;						// signed binary output
	reg [INT-1:-DEC] 					BRAM_B1 [0:32-1];
//////////////////////////////////////////////////////////////
	
	always @ (Pointer_B1) begin
		B1 = BRAM_B1 [Pointer_B1];
	end

	initial begin
		$readmemb("bias_1_b.txt", BRAM_B1);
	end
endmodule






// Load the all input feature map to BRAM, this is just for testing
module BRAM_IF (Pointer_IF, IF);
//////////////////////////////////////////////////////////////
	parameter							INT = 8;					// integer resolution of the input/output 
	parameter							DEC = 8;					// decimal resolution of the input/output
	
	input [13:0] 						Pointer_IF; 				// index for first B1 vector, 10000*(32*32*3) = 30720000 elements
	output reg signed [INT-1:-DEC] 		IF;							// signed binary output
	reg [INT-1:-DEC] 					BRAM_IF [0:30720-1];		// say test the first 10 pics
//////////////////////////////////////////////////////////////
	
	always @ (Pointer_IF) begin
		IF = BRAM_IF [Pointer_IF];
	end

	initial begin
		$readmemb("I_b.txt", BRAM_IF);
	end
endmodule





// Processing element
module PE(CLK, RST, Pointer_K1, Pointer_IF, Addr_PE, ACK, OUT_PE);
//////////////////////////////////////////////////////////////
	parameter							INT = 8;									// integer resolution of the input/output 
	parameter							DEC = 8;									// decimal resolution of the input/output
	parameter							E = 28;										// row dimension of the output feature maps
	parameter							R = 5;										// row dimension of the filter
	parameter 							U = 1;										// stride
	
 	input 								CLK, RST;
	input [11:0]						Pointer_K1;
	input [13:0]						Pointer_IF;									// pointers for kernel_1 and input feature maps
	input [4:0]							Addr_PE; 									// accessing address (0-27) of the "OUT_PE"
	
	output signed [INT-1:-DEC] 			OUT_PE; 									// wiring the OF_reg to output; Verilog does not support parallel output, SystemVerilog does			
	output 								ACK;
	
	reg signed [INT-1:-DEC]				OF_reg [0:E-1];								// output reg from one PE
	reg 								ACK_reg;									// ackowledgement signal that means one row is finished
	reg [2:0]							Counter_5;									// count up to 5 (0-5), if it is 5, the row of input feature map shifts rights (0 is for skipping the initial condition)
	reg [4:0]							Counter_28;									// count up to 28 (0-28), if it is 28, shift to another channel (both kernel and ifmap)	
	reg [4:0]							Buff_Counter; 								// buffering for the PE, tweak this guy to obtain more delays in between PEs, so that psum results wont be corrupted
	
	reg [11:0]							Pointer_K1_reg;
	reg [13:0]							Pointer_IF_reg;								// pointers for kernel_1 and input feature maps
	
	reg 								CLR_MAC, CLR_ACC;

	
	wire signed [INT-1:-DEC]			K1, IF;
	wire signed [INT-1:-DEC]			OUT_MAC;
//////////////////////////////////////////////////////////////
	
	BRAM_K1 Kernel_1(Pointer_K1_reg, K1);	
	BRAM_IF IF_Maps(Pointer_IF_reg, IF);
	MAC MAC_1(K1, IF, CLK, CLR_MAC, CLR_ACC, OUT_MAC);
	
	assign OUT_PE = OF_reg[Addr_PE];
	
	assign ACK = ACK_reg;
	
	always @ (posedge CLK) begin
		if (RST || ACK_reg) 											// reset everything 
		begin
			Counter_5 <= 0;
			Counter_28 <= 0;
			Buff_Counter <= 0;
			ACK_reg <= 0;
			CLR_MAC <= 1;
			CLR_ACC <= 1;
			Pointer_K1_reg <= 0;
			Pointer_IF_reg <= 0;
		end
			
		else if (Counter_5 == 0) 										// a buffer state that is ued to do the initialization
		begin
			if (Counter_28 == 0)
			begin
				if (Buff_Counter < E)
				begin
					Buff_Counter <= Buff_Counter + 1;
					Counter_28 <= 0;									// force it back to start this if loop again
				end
				else begin	
					CLR_MAC <= 0;
					CLR_ACC <= 0;
					Pointer_K1_reg <= Pointer_K1;						// load new kernel row data to the PE at initial condition
					Pointer_IF_reg <= Pointer_IF;						// load new ifmap row data to the PE at initial condition		
					Counter_5 <= Counter_5 + 1;
				end
			end
		end
		
		else if (Counter_5 == 1)										// actual computation starts from here
		begin
			CLR_ACC <= 0;
			Pointer_K1_reg <= Pointer_K1_reg + 1;
			Pointer_IF_reg <= Pointer_IF_reg + 1;
			Counter_5 <= Counter_5 + 1;
			OF_reg[Counter_28-1] <= OUT_MAC;
			if (Counter_28 == 28)										// reset the ifmap pointer to 0 if it is 28
			begin
				ACK_reg <= 1;
			end
		end
		
		else if (Counter_5 == 2)
		begin
			CLR_ACC <= 0;
			Pointer_K1_reg <= Pointer_K1_reg + 1;						// increment pointer of the kernel
			Pointer_IF_reg <= Pointer_IF_reg + 1;						// increment pointer of the ifmap
			Counter_5 <= Counter_5 + 1;									// goes to next state
		end
		
		else if (Counter_5 == 3)										// sames as above
		begin
			CLR_ACC <= 0;
			Pointer_K1_reg <= Pointer_K1_reg + 1;		
			Pointer_IF_reg <= Pointer_IF_reg + 1;
			Counter_5 <= Counter_5 + 1;
		end
		
		else if (Counter_5 == 4)										// same as above
		begin
			CLR_ACC <= 0;
			Pointer_K1_reg <= Pointer_K1_reg + 1;
			Pointer_IF_reg <= Pointer_IF_reg + 1;
			Counter_5 <= Counter_5 + 1;
		end
		
		else if (Counter_5 == 5)										// transient state
		begin
			CLR_ACC <= 1;												// clear the accumulation of the MAC
			Counter_5 <= 1;												// back to state where "Counter_5 = 1"
			Pointer_K1_reg <= Pointer_K1_reg - (R - 1); 				// shift the filter back to original positions
			Pointer_IF_reg <= Pointer_IF_reg - (R - U - 1);				// shift ifmap row by "U"
			Counter_28 <= Counter_28 + 1;
		end
	end
	
endmodule	



	
	
	
// first CNN layer implementation; 5*28 PEs	
module CNN (CLK, RST);
//////////////////////////////////////////////////////////////
	parameter							INT = 8;																		// integer resolution of the input/output 
	parameter							DEC = 8;																		// decimal resolution of the input/output
	parameter							C = 3;																			// channel dimension of ifmap and kernel
	parameter							E = 28;																			// row dimension of the ofmap
	parameter							F = 28;																			// column dimension of the ofmap
	parameter							R = 5;																			// row dimension of the filter
	parameter 							H = 32;																			// row dimension of the ifmap
	parameter 							M = 32;																			// number of filters													
	
	input 								CLK, RST;						
	
	reg [11:0]							Pointer_K1 [0:(R * E - 1)]; 		 											// pointer for each row of the kernel 1
	reg [11:0]							Pointer_K1_psum	[0:(R - 1)]; 													// group each PEs for one filter row pointer
	reg [13:0]							Pointer_IF [0:(R * E - 1)]; 													// pointer for each row of the ifmap
	reg [13:0]							Pointer_IF_psum	[0:(H - 1)];													// pointer for each diagnoal of PE arrays.
	reg [4:0]							Addr_PE [0:(R * E - 1)];														// address for retriving output from each PE								
	reg [4:0]							Addr_psum;																		// address for controlling all PEs	
	
	reg [2:0]							Counter_C;																		// channel counter, counts from 0-2
	reg [4:0]							Counter_K;																		// kernel counter, counts from 0-31 (also the address of bias)
	reg [13:0]							Counter_IF;																		// ifmap counter, in this example, it countes 0-9 10 pics
	reg 								Switch_psum;																	// swwitch for the psum result adding 
	reg 								ACK_ofmap;																		// ackowledgement signal to tell one ofmap is completed
	wire signed [INT-1:-DEC]			Bias;																			// bias for the first layer
	
	
	wire 								ACK_PE [0:(R * E - 1)]; 														// ackowledgement signal from each PE
	wire 								ACK_psum;																		// synchrounous ACK signal
	
	wire signed [INT-1:-DEC]			OUT_PE [0:(R * E - 1)];															// output wire from each PE
	reg signed [INT-1:-DEC]				OUT_psum [0:(E * F * M - 1)];													// psum from all columes of PEs, ofmap (32 channels, each channel has 28*28)
	
//////////////////////////////////////////////////////////////

	genvar a; 
	generate 
	    for (a = 0; a < (E * R); a = a + 1) begin: pe_array 															// generate 5*28 PEs 
			PE PE_Array(CLK, RST, Pointer_K1[a], Pointer_IF[a], Addr_PE[a], ACK_PE[a], OUT_PE[a]);	
		end
	endgenerate
	
	BRAM_B1 BIAS(Counter_K, Bias);															// loading bias
	
	// initilization...tie different registers together...
	integer m;																				// for Pointer_K1 initialization
	
	integer n;																				// for Pointer_IF initialization
	
	integer i;																				// for Pointer_K1 to Pointer_K1_psum mapping 
	integer j;																				// for Pointer_K1 to Pointer_K1_psum mapping
	
	integer k;																				// for pointer_IF to pointer_IF_psum  
	integer l;																				// for pointer_IF to pointer_IF_psum
	
	integer p;																				// for Addr_PE to Addr_psum mapping
	integer q;																				// for Addr_PE to Addr_psum mapping										
	integer w;																				// for Addr_psum initilization
	
	integer u;																				// for OUT_psum initilization
	
	integer kernel_p0;																		// kernel pointer
	integer ifmap_p0;																		// ifmap pointer

	integer kernel_p1;																		// kernel pointer
	integer ifmap_p1;																		// ifmap pointer
	
	integer kernel_p2;																		// reset the kernel
	integer ifmap_p2;																		// ifmap pointer

	integer kernel_p3;																		// kernel pointer
	integer ifmap_p3;																		// ifmap pointer

	integer kernel_p4;																		// kernel pointer
	integer ifmap_p4;																		// ifmap pointer
	
	integer x;																				// psum counter
	integer y;																				// psum counter

	genvar r;																				// for wire ACK_PE to ACK_psum mapping
	generate 
	for (r = 0; r < (R * E); r = r + 1)
	begin: ack_assign
		assign ACK_psum = ACK_PE[r];													// tie all wires ACK_PE with just one ACK_psum signal as they are all synchrounous
	end
	endgenerate
	
	always @ (posedge CLK) begin
		if (RST) 																			// State -1: reset everything back to initial condition (initialization stage)
		begin
			Counter_C <= 0;																	// channel counter
			Counter_K <= 0;																	// kernel counter
			Counter_IF <= 0;																// ifmap counter
			Switch_psum <= 0;																// psum switch initilization
			for (m = 0; m < R; m = m + 1)
			begin
				Pointer_K1_psum[m] <= 0;													// initialize Pointer_K1_psum
			end
			
			for (n = 0; n < M; n = n + 1)
			begin
				Pointer_IF_psum[n] <= 0;													// initialize Pointer_IF_psum
			end
			
			Addr_psum <= 0;																	// initialize Addr_psum
			
			for (u = 0; u < (E * F * M); u = u + 1)
			begin
				OUT_psum[u] <= 0;															// initialize OUT_psum
			end
			
		end
		
		else if (ACK_psum == 0 && Counter_C == 0 && Counter_K == 0)							// State 0: initial state
		begin
			for (kernel_p0 = 0; kernel_p0 < R; kernel_p0 = kernel_p0 + 1)
			begin
				Pointer_K1_psum[kernel_p0] <= kernel_p0 * R;
			end
			for (ifmap_p0 = 0; ifmap_p0 < H; ifmap_p0 = ifmap_p0 + 1)
			begin
				Pointer_IF_psum[ifmap_p0] <= ifmap_p0 * H;
			end
		end
		
		else if (ACK_psum == 0)																// State 1: when there is not ACK_psum signal, they remain themselves
		begin
			for (kernel_p1 = 0; kernel_p1 < R; kernel_p1 = kernel_p1 + 1)
			begin
				Pointer_K1_psum[kernel_p1] <= Pointer_K1_psum[kernel_p1];
			end
			for (ifmap_p1 = 0; ifmap_p1 < H; ifmap_p1 = ifmap_p1 + 1)
			begin
				Pointer_IF_psum[ifmap_p1] <= Pointer_IF_psum[ifmap_p1];
			end
		end
		
		// state 2.0 and state 2.1 are NOT exclusive
		if (ACK_psum == 1)																	// State 2.0: as long as there is an ACK_psum == 1, increment the channel counter no matter what
		begin
			Switch_psum	<= 1;																// turn on the switch the adding of the results
			if (Counter_C == (C - 1))														// if all 3 channels of one kernel are finished
			begin
				Counter_C <= 0; 															// means one kernel is completed
				if (Counter_K == (M - 1))													// if all kernels are used for one ifmap
				begin
					Counter_K <= 0;															// reset the kernel pointer back to initial
					for (kernel_p2 = 0; kernel_p2 < R; kernel_p2 = kernel_p2 + 1)
					begin
						Pointer_K1_psum[kernel_p2] <= kernel_p2 * R;
					end
					for (ifmap_p2 = 0; ifmap_p2 < H; ifmap_p2 = ifmap_p2 + 1)
					begin
						Pointer_IF_psum[ifmap_p2] <= Pointer_IF_psum[ifmap_p2] + (H * H);	// ifmap shifts one channel, a new ifmap comes in
					end
					Counter_IF <= Counter_IF + 1;											// increment ifmap counter
				end
				
				else 
				begin
					for (kernel_p3 = 0; kernel_p3 < R; kernel_p3 = kernel_p3 + 1)
					begin
						Pointer_K1_psum[kernel_p3] <= Pointer_K1_psum[kernel_p3] + (R * R);	// kernel shifts one channel
					end
					
					for (ifmap_p3 = 0; ifmap_p3 < H; ifmap_p3 = ifmap_p3 + 1)
					begin
						Pointer_IF_psum[ifmap_p3] <= Pointer_IF_psum[ifmap_p3] + (H * H);	// ifmap shifts one channel
					end
				end
				Counter_K <= Counter_K + 1;  												// shift to next kernel
			end
			
			else
			begin
				for (kernel_p4 = 0; kernel_p4 < R; kernel_p4 = kernel_p4 + 1)
				begin
					Pointer_K1_psum[kernel_p4] <= Pointer_K1_psum[kernel_p4] + (R * R);		// kernel shifts one channel
				end
				
				for (ifmap_p4 = 0; ifmap_p4 < H; ifmap_p4 = ifmap_p4 + 1)
				begin
					Pointer_IF_psum[ifmap_p4] <= Pointer_IF_psum[ifmap_p4] + (H * H);		// ifmap shifts one channel
				end
				Counter_C <= Counter_C + 1;	
			end
		end
		
		if (Switch_psum == 1)																// State 2.1: psum calculation
		begin
			if (Addr_psum < E)
			begin
				if (Counter_C < (C - 1))
				begin
					for (x = 0; x < E; x = x + 1)
					begin
						OUT_psum[Addr_psum + E * x + E * F * Counter_K] <= OUT_PE[x * 5] 				
									+ OUT_PE[x * 5 + 1] 
									+ OUT_PE[x * 5 + 2]
									+ OUT_PE[x * 5 + 3] 
									+ OUT_PE[x * 5 + 4]
									+ OUT_psum[Addr_psum + E * x + E * F * Counter_K];		// adding psum with the convolution results from all channels and allocate them to different channel based on 
																							// which kernel is the input
					end 
				end
				else 
				begin
					for (y = 0; y < E; y = y + 1)
					begin
						OUT_psum[Addr_psum + E * y + E * F * Counter_K] <= OUT_PE[y * 5] 				
									+ OUT_PE[y * 5 + 1] 
									+ OUT_PE[y * 5 + 2]
									+ OUT_PE[y * 5 + 3] 
									+ OUT_PE[y * 5 + 4]
									+ OUT_psum[Addr_psum + E * y + E * F * Counter_K]
									+ Bias;													// adding the result to the bias if one kernel is finished
						if (OUT_psum[Addr_psum + E * y + E * F * Counter_K] < 0)
						begin
							OUT_psum[Addr_psum + E * y + E * F * Counter_K] <= 0;			// ReLU function
						end
						else
						begin
							OUT_psum[Addr_psum + E * y + E * F * Counter_K] 
							<= OUT_psum[Addr_psum + E * y + E * F * Counter_K];
						end
					end
				end
				
				if (Counter_C == (C - 1) && Counter_K == (M - 1))							// if all the convolutions in between kernel sets and one ifmap (all channels) are finished 
				begin
					ACK_ofmap <= 1;															// send an ackowledgement signal to tell one ofmap is finished and data are ready for accessed 
				end		
				else 
				begin
					ACK_ofmap <= 0;
				end
				
				if (Addr_psum !== (E - 1))
				begin
					Addr_psum <= Addr_psum + 1;
				end
				else 
				begin
					Addr_psum <= 0;
					Switch_psum <= 0;
				end
			end
		end
	end
	
	always @ (*) begin																		// State0: mapping the PEs with appropriate pointers
		for (i = 0; i < R; i = i + 1)
		begin
			for (j = 0; j < (E * R); j = j + 5)
			begin
				Pointer_K1[i + j] <= Pointer_K1_psum[i];									// tie PEs with same kernel pointers, CHECKED!
			end
		end
		
		for (p = 0; p < (E * R); p = p + 1)
		begin
			Addr_PE[p] <= Addr_psum;														// use one address signal to control all PEs, CHECKED!
		end
		
		//------------------------------------//											// tricky... map Pointer_IF to Pointer_psum diagnoally
		Pointer_IF[0] <= Pointer_IF_psum[0];												// maps ifmap row 1 to Pointer_IF_psum diagnoally

		Pointer_IF[1] <= Pointer_IF_psum[1];												// maps ifmap row 2 to Pointer_IF_psum diagnoally
		Pointer_IF[5] <= Pointer_IF_psum[1];
		
		Pointer_IF[2] <= Pointer_IF_psum[2];												// maps ifmap row 3 to Pointer_IF_psum diagnoally
		Pointer_IF[6] <= Pointer_IF_psum[2];
		Pointer_IF[10] <= Pointer_IF_psum[2];
		
		Pointer_IF[3] <= Pointer_IF_psum[3];
		Pointer_IF[7] <= Pointer_IF_psum[3];
		Pointer_IF[11] <= Pointer_IF_psum[3];
		Pointer_IF[15] <= Pointer_IF_psum[3];
		
		for (k = 4; k < 28; k = k + 1)														// maps ifmap row 4-27 to Pointer_IF_psum diagnoally 
		begin
			for (l = 0; l < R; l = l + 1)
			begin
				Pointer_IF[k + l * 4 + 4 * (k - 4)] <= Pointer_IF_psum[k];					// "k + l * 4 + 4 * (k - 4) <= k", very tricky correlation...., CHECKED!
			end
		end
		Pointer_IF[124] <= Pointer_IF_psum[28];												// maps ifmap row 28 to Pointer_IF_psum diagnoally
		Pointer_IF[128] <= Pointer_IF_psum[28];
		Pointer_IF[132] <= Pointer_IF_psum[28];
		Pointer_IF[136] <= Pointer_IF_psum[28];
			
		Pointer_IF[129] <= Pointer_IF_psum[29];												// maps ifmap row 29 to Pointer_IF_psum diagnoally
		Pointer_IF[133] <= Pointer_IF_psum[29];
		Pointer_IF[137] <= Pointer_IF_psum[29];

		Pointer_IF[134] <= Pointer_IF_psum[30];												// maps ifmap row 30 to Pointer_IF_psum diagnoally
		Pointer_IF[138] <= Pointer_IF_psum[30];
		
		Pointer_IF[139] <= Pointer_IF_psum[31];												// maps ifmap row 31 to Pointer_IF_psum diagnoally
		//------------------------------------//
	end
	
endmodule
	
